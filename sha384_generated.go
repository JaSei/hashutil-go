// Code generated by github.com/jasei/hashutil/generator DO NOT EDIT
package hashutil

import (
	"bytes"
	"encoding/base64"
	"encoding/hex"
	"fmt"
	"hash"
	"strings"
)

// Sha384 type represents Sha384 checksum
type Sha384 []byte

// StringToSha384 return a new Sha384 checksum from string (hex) representation
func StringToSha384(hexString string) (Sha384, error) {
	bytes, err := hex.DecodeString(hexString)
	if err != nil {
		return Sha384{}, err
	}

	return BytesToSha384(bytes)
}

// BytesToSha384 return a new Sha384 checksum from bytes (binary) representation
func BytesToSha384(bytes []byte) (Sha384, error) {
	if len(bytes) != 48 {
		return Sha384{}, fmt.Errorf("Hash function Sha384 must have a length of 48 bytes (actual have %d)", len(bytes))
	}

	return Sha384(bytes), nil

}

//HashToSha384 return a new Sha384 checksum from hash.Hash representation
// HashToSha384 convert hashutil.Hash to Sha384
func HashToSha384(h hash.Hash) (Sha384, error) {
	return BytesToSha384(h.Sum(nil))
}

// EmptySha384 return Sha384 of empty file
func EmptySha384() Sha384 {
	h, _ := StringToSha384("38b060a751ac96384cd9327eb1b1e36a21fdb71114be07434c0cc7bf63f6e1da274edebfe76f65fbd51ad2f14898b95b")
	return h
}

// Equal return true if is Sha384s equal
func (h Sha384) Equal(o Sha384) bool {
	return bytes.Equal(h, o)
}

// String return (hex) string representation of Sha384
func (h Sha384) String() string {
	return hex.EncodeToString(h)
}

// UpperString return (hex) string representation in upper case of Sha384
func (h Sha384) UpperString() string {
	return strings.ToUpper(hex.EncodeToString(h))
}

// ToBytes return []byte of hashutil.Sha384
func (h Sha384) ToBytes() []byte {
	return h
}

// ToBase64 return base64 representation of Sha384
func (h Sha384) ToBase64() string {
	return base64.StdEncoding.EncodeToString(([]byte)(h))
}

// IsEmpty return true if is Sha384 'empty hash'
func (h Sha384) IsEmpty() bool {
	return EmptySha384().Equal(h)
}
