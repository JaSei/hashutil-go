// Code generated by github.com/jasei/hashutil/generator DO NOT EDIT
package hashutil

import (
	"bytes"
	"encoding/base64"
	"encoding/hex"
	"fmt"
	"hash"
	"strings"
)

// Sha512 type represents Sha512 checksum
type Sha512 []byte

// StringToSha512 return a new Sha512 checksum from string (hex) representation
func StringToSha512(hexString string) (Sha512, error) {
	bytes, err := hex.DecodeString(hexString)
	if err != nil {
		return Sha512{}, err
	}

	return BytesToSha512(bytes)
}

// BytesToSha512 return a new Sha512 checksum from bytes (binary) representation
func BytesToSha512(bytes []byte) (Sha512, error) {
	if len(bytes) != 64 {
		return Sha512{}, fmt.Errorf("Hash function Sha512 must have a length of 64 bytes (actual have %d)", len(bytes))
	}

	return Sha512(bytes), nil

}

//HashToSha512 return a new Sha512 checksum from hash.Hash representation
// HashToSha512 convert hashutil.Hash to Sha512
func HashToSha512(h hash.Hash) (Sha512, error) {
	return BytesToSha512(h.Sum(nil))
}

// EmptySha512 return Sha512 of empty file
func EmptySha512() Sha512 {
	h, _ := StringToSha512("cf83e1357eefb8bdf1542850d66d8007d620e4050b5715dc83f4a921d36ce9ce47d0d13c5d85f2b0ff8318d2877eec2f63b931bd47417a81a538327af927da3e")
	return h
}

// Equal return true if is Sha512s equal
func (h Sha512) Equal(o Sha512) bool {
	return bytes.Equal(h, o)
}

// String return (hex) string representation of Sha512
func (h Sha512) String() string {
	return hex.EncodeToString(h)
}

// UpperString return (hex) string representation in upper case of Sha512
func (h Sha512) UpperString() string {
	return strings.ToUpper(hex.EncodeToString(h))
}

// ToBytes return []byte of hashutil.Sha512
func (h Sha512) ToBytes() []byte {
	return h
}

// ToBase64 return base64 representation of Sha512
func (h Sha512) ToBase64() string {
	return base64.StdEncoding.EncodeToString(([]byte)(h))
}

// IsEmpty return true if is Sha512 'empty hash'
func (h Sha512) IsEmpty() bool {
	return EmptySha512().Equal(h)
}
