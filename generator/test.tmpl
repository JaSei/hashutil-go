{{define "TEST"}}
// Code generated by github.com/jasei/hashutil/generator DO NOT EDIT
package hashutil

import (
    {{range .CryptoTest.Imports}}"{{.}}"
    {{end}}"strings"
	"testing"

	"github.com/stretchr/testify/assert"
)

const testEmpty{{.Hash}}String = "{{.EmptyHash}}"
const testEmpty{{.Hash}}Base64 = "{{.EmptyBase64Hash}}"

func Test{{.Hash}}StringToHashAndEqual(t *testing.T) {
	_, err := StringTo{{.Hash}}("")
	assert.Error(t, err, "Empty string isn't valid hash")
	assert.Equal(t, err.Error(), "Hash function {{.Hash}} must have a length of {{.Size}} bytes (actual have 0)")

    first := true
    invalidHash := strings.Map(func(r rune) rune {
		if first {
			first = false
			return 'x'
		}
		return r
	}, testEmpty{{.Hash}}String)

    _, err = StringTo{{.Hash}}(invalidHash)
	assert.Error(t, err, "x isn't isn't valid char in hash")

	hash, err := StringTo{{.Hash}}(testEmpty{{.Hash}}String)
	assert.NoError(t, err, "Convert string to {{.Hash}} without errors")

	hash2, err := StringTo{{.Hash}}(strings.ToUpper(testEmpty{{.Hash}}String))
	assert.NoError(t, err, "Convert string to {{.Hash}} without errors")

	assert.Equal(t, hash, hash2, "Upper and lower of same {{.Hash}} are equal")

	assert.True(t, hash.Equal(hash2) && hash2.Equal(hash))
}

func Test{{.Hash}}BytesToHash(t *testing.T) {
	_, err := BytesTo{{.Hash}}([]byte{})
	assert.Error(t, err)

    bytesHash := make([]byte, {{.Size}})

	_, err = BytesTo{{.Hash}}(bytesHash)
	assert.NoError(t, err)
}

func Test{{.Hash}}EmptyHash(t *testing.T) {
	hash, err := StringTo{{.Hash}}(testEmpty{{.Hash}}String)
	assert.NoError(t, err)
	assert.Equal(t, hash, Empty{{.Hash}}())
}

func Test{{.Hash}}HashToString(t *testing.T) {
	hash, err := StringTo{{.Hash}}(testEmpty{{.Hash}}String)
	assert.NoError(t, err)
	assert.Equal(t, hash.String(), testEmpty{{.Hash}}String)
	assert.Equal(t, hash.UpperString(), strings.ToUpper(testEmpty{{.Hash}}String))
}

func Test{{.Hash}}IsEmpty(t *testing.T) {
	hash, err := StringTo{{.Hash}}(testEmpty{{.Hash}}String)
	assert.NoError(t, err)
	assert.True(t, hash.IsEmpty())
}

func Test{{.Hash}}HashTo(t *testing.T) {
	hash, err := HashTo{{.Hash}}({{.CryptoTest.New}}())
	assert.NoError(t, err)
	assert.True(t, hash.IsEmpty())

	_, err = HashTo{{.Hash}}({{.CryptoTest.NewOther}}())
	assert.Error(t, err, "Invalid hash ({{.CryptoTest.New}} vs {{.CryptoTest.NewOther}})")
}

func Test{{.Hash}}HashToBase64(t *testing.T) {
	assert.Equal(t, testEmpty{{.Hash}}Base64, Empty{{.Hash}}().ToBase64())
}

func Test{{.Hash}}HashToBytes(t *testing.T) {
	h := Empty{{.Hash}}()
	h2, err := BytesTo{{.Hash}}(h.ToBytes())
	assert.NoError(t, err)
	assert.True(t, h.Equal(h2))
}
{{end}}
